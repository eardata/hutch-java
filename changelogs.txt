v2.0.0
* 因为 publish 的消息变多, 为了便于代码维护与清晰使用. 使用独立三个 Publisher
  * BodyPushlisher 负责字符串与二进制传递给 MQ
  * JsonPushlisher 负将对象转化为 JSON 格式传递给 MQ
  * LimitPublisher 负责需要进行主动 Ratelimit 的消息以 JSON 格式发送给 Redis 缓存, 再根据主动频率提交给 MQ
* 修复 Hutch 所管理的 ScheduleExecutor 的实例启停的问题
* 调整 Threshold 接口, 修改 publish 接口为 batch 接口, 返回需要的 `Consumer<List<String>>` 可进行 bathc 消息处理

v1.4.0
* 将主动限流需要的 schedule 使用 SchdeudleExecutor 代替额外的三方 Quartz 库

v1.3.2
* 增加支持 Threshold 接口, 并且需要依赖 Redis 做主动限流的机制. 用于解决三方 api 的调用限速问题

v1.3.0
* 增加基于 redis 的 schedule publish 支持

v1.2.0
* 为 HutchConsumer 的 onMessage 增加可抛出异常, 自定义流程控制什么情况可直接触发 ErrorHandler
* 增加申明 quorum queue 队列, 使用 rabbitmq 的分布式队列进行任务处理

v1.1.1
* 修复 publishJsonWithDelay 没有指定 message ttl 的 bug

v1.1.0
* 确定 Hutch 在整个 quarkus 实例中只存在一个实例, 因为需要从当前 quarkus 实例中寻找所有 HutchConsumer 进行初始化
* 修复 currentHutch 有初始化但没有进行 clear 的 bug 问题.
* 取消为每一个 HutchConsumer 创建一个 Connection 的问题, 因为现在的使用场景中, 很少并发到 100 的, 所以调整为一个
 Connection 处理消息发送, 一个 Connection 用于 Consumer. 特别高并发时候注意 rabbitmq 的 channel_max 参数(default: 2047).
* 将 static 方法的调用与 instance 方法区分开

v1.0.3
* 提供 ErrorHandler 的机制来扩充消发生错误之后的处理方式
* 支持简单的利用 fridujo 的 MockConnectionFactory 来进行 rabbitmq 的测试, 但推荐还是部署 rabbitmq 实例环境
